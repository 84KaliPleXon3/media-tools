# -*- coding: utf-8 -*-

import argparse
import collections
import inspect
import json
import math
from matplotlib import pyplot as plt
import numpy as np
import os
from pprint import pprint
import sys
import time

# add parent directory to sys path to import relative modules
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
parentdir = os.path.dirname(parentdir)
sys.path.insert(0,parentdir)

from lib.io_utils import *
from lib.collection_utils import *
from lib.processing_utils import *

# input
parser = argparse.ArgumentParser()
parser.add_argument('-in', dest="INPUT_FILE", default="tmp/loc/lc_pd_audio.csv", help="File generated by collect_metadata.py")
parser.add_argument('-pages', dest="INPUT_PAGES_FILES", default="output/loc/pd_audio/page_*.json", help="File pattern for json files downloaded from download_query.py")
parser.add_argument('-count', dest="DISPLAY_COUNT", default=25, type=int, help="Number to display per group")
parser.add_argument('-filter', dest="FILTER", default="", help="Filter string")
a = parser.parse_args()

fieldNames, files = readCsv(a.INPUT_FILE)
filenames = getFilenames(a.INPUT_PAGES_FILES)

filters = []
if len(a.FILTER) > 0:
    filters = parseFilterString(a.FILTER.strip())

# Filter out invalid files
files = filterWhere(files, [("duration", 0, ">"), ("hasAudio", 0, ">")])
fileCount = len(files)

items = []
for fn in filenames:
    items += readJSON(fn)
itemCount = len(items)
print("Read %s items" % itemCount)

itemLookup = {}
for i, item in enumerate(items):
    itemUrl = item["id"]
    itemId = itemUrl.strip("/").split("/")[-1]
    itemLookup[str(itemId)] = item

print("Total items retrieved from query: %s" % itemCount)
print("Total items with valid audio: %s (%s%%)" % (fileCount, round(1.0*fileCount / itemCount * 100.0, 2)))


def isValidFile(f, filters):
    global itemLookup
    valid = True
    if str(f["id"]) in itemLookup:
        if len(filters) > 0:
            metadata = itemLookup[str(f["id"])]
            for key, value, mode in filters:
                if key not in metadata:
                    valid = False
                    break
                if value not in metadata[key]:
                    valid = False
                    break
    else:
        valid = False

    return valid

files = [f for f in files if isValidFile(f, filters)]
fileCount = len(files)
print("Total items after filtering: %s (%s%%)" % (fileCount, round(1.0*fileCount / itemCount * 100.0, 2)))

durations = [f["duration"] for f in files]
totalSeconds = sum(durations)
medianSeconds = np.median(durations)
minSeconds, maxSeconds = (min(durations), max(durations))
print("Total duration: %s" % formatSeconds(totalSeconds, showDays=True))
print("Median item duration: %s" % formatSeconds(medianSeconds))
print("Min item duration: %s" % formatSeconds(minSeconds))
print("Max item duration: %s" % formatSeconds(maxSeconds))

reports = ['subject', 'partof', 'contributor', 'language']
reportData = {}
for key in reports:
    values = []
    for f in files:
        metadata = itemLookup[str(f["id"])]
        if key in metadata:
            values += metadata[key]
    if key == 'dates':
        # convert dates to years
        for j, v in enumerate(values):
            values[j] = v[:4]
    uvalues = unique(values)
    # reportData[key] = {
    #     'values': values,
    #     'uvalues': uvalues
    # }
    print('==============================================================================')
    print('%s (%s unique values) / Top %s:' % (key.capitalize(), len(uvalues), a.DISPLAY_COUNT))
    print('------------------------------------------------------------------------------')
    counter = collections.Counter(values)
    counts = counter.most_common(a.DISPLAY_COUNT)
    for value, count in counts:
        print("%s (%s%%)\t %s" % (count, round(1.0*count / fileCount * 100.0, 2), value))

# Make a histogram of dates
years = []
for f in files:
    metadata = itemLookup[str(f["id"])]
    values = []
    if 'dates' in metadata:
        values = metadata['dates']
    # convert dates to years
    for j, v in enumerate(values):
        years.append(int(v[:4]))
uyears = unique(years)

plt.figure(figsize=(12,6))
plt.hist(years, bins=len(uyears))
plt.tight_layout()
plt.show()
